# è¦–è¦ºåŒ–æ–¹æ¡ˆæ¯”è¼ƒ

## ğŸ¨ Three.js vs Drake MeshCat

### ç•¶å‰æ–¹æ¡ˆï¼šThree.js + React Three Fiber

**å„ªé»ï¼š**
- âœ… ç¾è§€çš„è‡ªå®šç¾© 3D æ¸²æŸ“
- âœ… å®Œå…¨æ§åˆ¶è¦–è¦ºæ•ˆæœ
- âœ… èˆ‡ React ç„¡ç¸«æ•´åˆ
- âœ… è±å¯Œçš„å‹•ç•«æ•ˆæœ
- âœ… å¿«é€Ÿæ¸²æŸ“

**ç¼ºé»ï¼š**
- âŒ éœ€è¦æ‰‹å‹•å¯¦ç¾ IK
- âŒ ç‰©ç†æ¨¡æ“¬ä¸æº–ç¢º
- âŒ æ²’æœ‰ç¢°æ’æª¢æ¸¬
- âŒ è»Œè·¡è¦åŠƒéœ€è¦è‡ªå·±å¯¦ç¾

**é©åˆå ´æ™¯ï¼š**
- è¦–è¦ºå±•ç¤ºç‚ºä¸»
- ä¸éœ€è¦ç²¾ç¢ºç‰©ç†æ¨¡æ“¬
- é‡è¦–ç¾è§€å’Œæµæš¢åº¦

---

### å»ºè­°æ–¹æ¡ˆï¼šDrake MeshCat

**å„ªé»ï¼š**
- âœ… ç²¾ç¢ºçš„é‹å‹•å­¸å’Œå‹•åŠ›å­¸
- âœ… å…§å»ºç¢°æ’æª¢æ¸¬
- âœ… å°ˆæ¥­çš„è»Œè·¡è¦åŠƒ
- âœ… çœŸå¯¦çš„ç‰©ç†æ¨¡æ“¬
- âœ… URDF æ¨¡å‹æ”¯æ´
- âœ… å¯åŒ¯å‡ºçœŸå¯¦æ©Ÿå™¨äººä»£ç¢¼

**ç¼ºé»ï¼š**
- âŒ è¦–è¦ºæ•ˆæœè¼ƒç°¡å–®
- âŒ è‡ªå®šç¾©æ¨£å¼å›°é›£
- âŒ éœ€è¦ Python å¾Œç«¯
- âŒ å­¸ç¿’æ›²ç·šè¼ƒé™¡

**é©åˆå ´æ™¯ï¼š**
- éœ€è¦ç²¾ç¢ºæ¨¡æ“¬
- è¦åŠƒçœŸå¯¦æ©Ÿå™¨äººå‹•ä½œ
- ç ”ç©¶å’Œé–‹ç™¼ç”¨é€”

---

## ğŸ—ï¸ æ··åˆæ–¹æ¡ˆï¼ˆæ¨è–¦ï¼‰

**çµåˆå…©è€…å„ªé»ï¼š**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            å‰ç«¯ (React)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Three.js    â”‚      â”‚  Drake MeshCat   â”‚    â”‚
â”‚  â”‚  ç¾åŒ–å±•ç¤º    â”‚      â”‚  ç²¾ç¢ºæ¨¡æ“¬        â”‚    â”‚
â”‚  â”‚  (ä¸»è¦è¦–åœ–)  â”‚      â”‚  (å¯åˆ‡æ›)        â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â–²                      â–²                 â”‚
â”‚         â”‚                      â”‚                 â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                    â”‚                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ WebSocket
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          å¾Œç«¯ (Python + Flask)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚        Drake é‹å‹•è¦åŠƒå¼•æ“                  â”‚  â”‚
â”‚  â”‚  - IK/FK è¨ˆç®—                              â”‚  â”‚
â”‚  â”‚  - è»Œè·¡è¦åŠƒ                                â”‚  â”‚
â”‚  â”‚  - ç¢°æ’æª¢æ¸¬                                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å·¥ä½œæµç¨‹ï¼š

1. **Drake å¾Œç«¯**ï¼š
   - é€²è¡Œç²¾ç¢ºçš„ IK/FK è¨ˆç®—
   - è¦åŠƒå¹³æ»‘è»Œè·¡
   - æª¢æ¸¬ç¢°æ’
   - é©—è­‰å‹•ä½œå¯è¡Œæ€§

2. **å‰ç«¯é¡¯ç¤º**ï¼š
   - **ä¸»è¦–åœ–**ï¼šThree.js æ¸²æŸ“ï¼ˆç¾è§€æµæš¢ï¼‰
   - **é©—è­‰è¦–åœ–**ï¼šDrake MeshCatï¼ˆç²¾ç¢ºæ¨¡æ“¬ï¼‰
   - ä½¿ç”¨è€…å¯ä»¥åˆ‡æ›è¦–åœ–

3. **æ•¸æ“šåŒæ­¥**ï¼š
   - å¾Œç«¯è¨ˆç®—é—œç¯€è§’åº¦
   - WebSocket å³æ™‚å‚³é€
   - å…©å€‹è¦–åœ–åŒæ­¥æ›´æ–°

---

## ğŸ“Š å¯¦ä½œç¯„ä¾‹

### 1. å¾Œç«¯ï¼šDrake è¨ˆç®— + MeshCat

```python
# backend/app/services/drake_hybrid_service.py

from pydrake.all import *
from flask_socketio import SocketIO

class DrakeHybridService:
    def __init__(self, socketio):
        self.socketio = socketio

        # Drake æ¨¡æ“¬å™¨ï¼ˆç”¨æ–¼è¨ˆç®—ï¼‰
        self.setup_drake()

        # MeshCatï¼ˆç”¨æ–¼é©—è­‰è¦–è¦ºåŒ–ï¼‰
        self.meshcat = StartMeshcat()

    def setup_drake(self):
        self.builder = DiagramBuilder()
        self.plant, self.scene_graph = \
            MultibodyPlant.AddMultibodyPlantSceneGraph(
                self.builder, time_step=0.001
            )

        parser = Parser(self.plant, self.scene_graph)
        parser.AddModelFromFile("models/ur5.urdf")
        self.plant.Finalize()

        # æ·»åŠ  MeshCat è¦–è¦ºåŒ–
        MeshcatVisualizer.AddToBuilder(
            self.builder,
            self.scene_graph,
            self.meshcat
        )

        self.diagram = self.builder.Build()
        self.simulator = Simulator(self.diagram)

    def plan_motion(self, start_pos, end_pos, rotation_angle):
        '''è¦åŠƒå‹•ä½œä¸¦è¿”å›è»Œè·¡'''

        # 1. è¨ˆç®—èµ·é»å’Œçµ‚é»çš„é—œç¯€è§’åº¦
        q_start = self.solve_ik(start_pos, rotation_angle)
        q_end = self.solve_ik(end_pos, rotation_angle)

        if q_start is None or q_end is None:
            return None

        # 2. ä½¿ç”¨ Drake è¦åŠƒå¹³æ»‘è»Œè·¡
        trajectory = self.plan_trajectory(q_start, q_end)

        # 3. æ›´æ–° MeshCat è¦–è¦ºåŒ–
        self.update_meshcat_visualization(trajectory)

        # 4. ç™¼é€è»Œè·¡åˆ°å‰ç«¯
        self.socketio.emit('trajectory_update', {
            'trajectory': trajectory,
            'meshcat_url': self.meshcat.web_url()
        })

        return trajectory

    def solve_ik(self, position, rotation):
        '''æ±‚è§£ IK'''
        ik = InverseKinematics(self.plant)

        # æœ«ç«¯æ•ˆæ‡‰å™¨
        ee_frame = self.plant.GetFrameByName("end_effector")

        # ä½ç½®ç´„æŸ
        ik.AddPositionConstraint(
            ee_frame,
            [0, 0, 0],
            self.plant.world_frame(),
            position,
            position
        )

        # å§¿æ…‹ç´„æŸï¼ˆè€ƒæ…®æ—‹è½‰è§’åº¦ï¼‰
        R = RotationMatrix.MakeZRotation(np.radians(rotation))
        ik.AddOrientationConstraint(
            ee_frame,
            R,
            self.plant.world_frame(),
            RotationMatrix(),
            0.01
        )

        result = Solve(ik.prog())

        if result.is_success():
            return result.GetSolution(ik.q())
        return None

    def plan_trajectory(self, q_start, q_end, duration=2.0):
        '''è¦åŠƒè»Œè·¡'''
        # ä½¿ç”¨ä¸‰æ¬¡å¤šé …å¼æ’å€¼
        num_points = int(duration * 50)  # 50 Hz
        t = np.linspace(0, duration, num_points)

        trajectory = []
        for i in range(num_points):
            s = t[i] / duration
            s_smooth = 3 * s**2 - 2 * s**3  # å¹³æ»‘æ’å€¼

            q = q_start + s_smooth * (q_end - q_start)

            # è¨ˆç®—æœ«ç«¯ä½ç½®ï¼ˆç”¨æ–¼å‰ç«¯é¡¯ç¤ºï¼‰
            pos, rot = self.compute_forward_kinematics(q)

            trajectory.append({
                'time': t[i],
                'joint_angles': q.tolist(),
                'end_effector_pos': pos,
                'end_effector_rot': rot
            })

        return trajectory

    def compute_forward_kinematics(self, q):
        '''æ­£å‘é‹å‹•å­¸'''
        context = self.plant.CreateDefaultContext()
        self.plant.SetPositions(context, q)

        ee_frame = self.plant.GetFrameByName("end_effector")
        transform = self.plant.CalcRelativeTransform(
            context,
            self.plant.world_frame(),
            ee_frame
        )

        return (
            transform.translation().tolist(),
            transform.rotation().ToQuaternion().wxyz().tolist()
        )

    def update_meshcat_visualization(self, trajectory):
        '''æ›´æ–° MeshCat è¦–è¦ºåŒ–'''
        context = self.simulator.get_mutable_context()

        for point in trajectory:
            q = np.array(point['joint_angles'])
            self.plant.SetPositions(
                self.plant.GetMyContextFromRoot(context),
                q
            )
            self.diagram.ForcedPublish(context)
```

### 2. å‰ç«¯ï¼šé›™è¦–åœ–é¡¯ç¤º

```typescript
// frontend/src/components/HybridViewer.tsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  Tabs,
  Tab,
  Paper,
  Switch,
  FormControlLabel
} from '@mui/material';
import Scene3D from './3d/Scene3D';  // Three.js è¦–åœ–
import io from 'socket.io-client';

interface TrajectoryPoint {
  time: number;
  joint_angles: number[];
  end_effector_pos: number[];
  end_effector_rot: number[];
}

const HybridViewer: React.FC = () => {
  const [activeTab, setActiveTab] = useState(0);
  const [meshcatUrl, setMeshcatUrl] = useState<string>('');
  const [trajectory, setTrajectory] = useState<TrajectoryPoint[]>([]);
  const [currentFrame, setCurrentFrame] = useState(0);
  const [syncViews, setSyncViews] = useState(true);

  useEffect(() => {
    // ç²å– MeshCat URL
    fetch('/api/meshcat_url')
      .then(res => res.json())
      .then(data => setMeshcatUrl(data.url));

    // é€£æ¥ WebSocket
    const socket = io('http://localhost:5000');

    socket.on('trajectory_update', (data) => {
      console.log('Trajectory received:', data);
      setTrajectory(data.trajectory);
    });

    return () => {
      socket.disconnect();
    };
  }, []);

  // å‹•ç•«æ’­æ”¾
  useEffect(() => {
    if (trajectory.length === 0) return;

    const interval = setInterval(() => {
      setCurrentFrame(prev => {
        const next = (prev + 1) % trajectory.length;
        return next;
      });
    }, 1000 / 50);  // 50 Hz

    return () => clearInterval(interval);
  }, [trajectory]);

  return (
    <Box>
      {/* è¦–åœ–åˆ‡æ›æ¨™ç±¤ */}
      <Paper sx={{ mb: 2 }}>
        <Tabs value={activeTab} onChange={(e, v) => setActiveTab(v)}>
          <Tab label="ğŸ¨ Three.js (ç¾åŒ–)" />
          <Tab label="ğŸ”¬ Drake MeshCat (ç²¾ç¢º)" />
          <Tab label="ğŸ“Š åˆ†å±æ¯”è¼ƒ" />
        </Tabs>

        <Box sx={{ p: 2 }}>
          <FormControlLabel
            control={
              <Switch
                checked={syncViews}
                onChange={(e) => setSyncViews(e.target.checked)}
              />
            }
            label="åŒæ­¥å…©å€‹è¦–åœ–"
          />
        </Box>
      </Paper>

      {/* Three.js è¦–åœ– */}
      {(activeTab === 0 || activeTab === 2) && (
        <Box sx={{
          width: activeTab === 2 ? '50%' : '100%',
          display: 'inline-block'
        }}>
          <Scene3D
            jointAngles={
              trajectory[currentFrame]?.joint_angles || []
            }
          />
        </Box>
      )}

      {/* Drake MeshCat è¦–åœ– */}
      {(activeTab === 1 || activeTab === 2) && (
        <Box sx={{
          width: activeTab === 2 ? '50%' : '100%',
          display: 'inline-block'
        }}>
          {meshcatUrl && (
            <iframe
              src={meshcatUrl}
              style={{
                width: '100%',
                height: '600px',
                border: 'none'
              }}
              title="Drake MeshCat"
            />
          )}
        </Box>
      )}
    </Box>
  );
};

export default HybridViewer;
```

### 3. API è·¯ç”±

```python
# backend/app/routes/hybrid_sim.py

from flask import Blueprint, jsonify, request
from app.services.drake_hybrid_service import drake_service

hybrid_bp = Blueprint('hybrid', __name__)

@hybrid_bp.route('/api/meshcat_url')
def get_meshcat_url():
    '''ç²å– MeshCat URL'''
    return jsonify({
        'url': drake_service.meshcat.web_url()
    })

@hybrid_bp.route('/api/plan_pick', methods=['POST'])
def plan_pick_motion():
    '''è¦åŠƒæŠ“å–å‹•ä½œ'''
    data = request.json

    # ç‰©ä»¶ä½ç½®å’Œæ—‹è½‰è§’åº¦ï¼ˆä¾†è‡ªè¦–è¦ºæª¢æ¸¬ï¼‰
    object_pos = data['object_position']  # [x, y, z]
    rotation = data['rotation_angle']     # degrees

    # ç•¶å‰ä½ç½®
    current_pos = data['current_position']

    # ä½¿ç”¨ Drake è¦åŠƒå‹•ä½œ
    trajectory = drake_service.plan_motion(
        start_pos=current_pos,
        end_pos=object_pos,
        rotation_angle=rotation
    )

    if trajectory:
        return jsonify({
            'success': True,
            'trajectory': trajectory
        })
    else:
        return jsonify({
            'success': False,
            'error': 'Motion planning failed'
        }), 400
```

---

## ğŸ¯ æ¨è–¦å¯¦ä½œæ­¥é©Ÿ

### Phase 1: ä¿ç•™ Three.jsï¼ŒåŠ å…¥ Drake å¾Œç«¯

1. âœ… å®‰è£ Drake
2. âœ… å‰µå»º Drake æœå‹™é¡åˆ¥
3. âœ… å»ºç«‹ API ç«¯é»
4. âœ… å‰ç«¯é€é API ç²å–è¨ˆç®—çµæœ
5. âœ… Three.js ä½¿ç”¨ Drake è¨ˆç®—çš„è§’åº¦

**å„ªé»**ï¼šæ¼¸é€²å¼æ•´åˆï¼Œé¢¨éšªä½

### Phase 2: åŠ å…¥ Drake MeshCat è¦–åœ–

1. âœ… å•Ÿå‹• MeshCat æœå‹™
2. âœ… å‰ç«¯æ·»åŠ  iframe é¡¯ç¤º MeshCat
3. âœ… å¯¦ä½œè¦–åœ–åˆ‡æ›åŠŸèƒ½
4. âœ… åŒæ­¥å…©å€‹è¦–åœ–çš„ç‹€æ…‹

**å„ªé»**ï¼šå¯ä»¥é©—è­‰ç²¾ç¢ºåº¦

### Phase 3: å®Œæ•´æ•´åˆ

1. âœ… æ•´åˆç‰©ä»¶æª¢æ¸¬
2. âœ… è‡ªå‹•è¦åŠƒæŠ“å–å‹•ä½œ
3. âœ… ç¢°æ’æª¢æ¸¬
4. âœ… å¤šç‰©ä»¶è™•ç†

---

## ğŸ’¡ æœ€çµ‚å»ºè­°

**å°æ–¼ä½ çš„ AOI ç³»çµ±ï¼Œå»ºè­°ä½¿ç”¨æ··åˆæ–¹æ¡ˆï¼š**

1. **é–‹ç™¼/æ¸¬è©¦éšæ®µ**ï¼š
   - ä¸»è¦ä½¿ç”¨ Drake MeshCat
   - ç¢ºä¿å‹•ä½œç²¾ç¢ºç„¡èª¤
   - é©—è­‰ç¢°æ’æª¢æ¸¬

2. **å±•ç¤º/ç”Ÿç”¢éšæ®µ**ï¼š
   - ä¸»è¦ä½¿ç”¨ Three.js
   - ç¾è§€æµæš¢çš„è¦–è¦ºæ•ˆæœ
   - å¿…è¦æ™‚åˆ‡æ›åˆ° Drake é©—è­‰

3. **å¯¦éš›éƒ¨ç½²åˆ°æ©Ÿå™¨äºº**ï¼š
   - ä½¿ç”¨ Drake ç”Ÿæˆçš„è»Œè·¡
   - ç›´æ¥è½‰æ›ç‚ºæ©Ÿå™¨äººæŒ‡ä»¤
   - ä¿è­‰ç²¾ç¢ºæ€§å’Œå®‰å…¨æ€§

---

## ğŸ“š ä¸‹ä¸€æ­¥

1. è©¦é‹è¡Œ `02_drake_visualization.py`
2. ç†Ÿæ‚‰ Drake çš„ IK å’Œè»Œè·¡è¦åŠƒ
3. æ•´åˆæ—‹è½‰è§’åº¦æª¢æ¸¬
4. å»ºç«‹æ··åˆè¦–åœ–ç³»çµ±
